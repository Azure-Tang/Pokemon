# 宠物小精灵对战系统文档

## 一、题目要求

### 题目一：宠物小精灵的加入

> 设计宠物小精灵的类，为简化游戏设计，精灵的属性包括种类（力量型：高攻击； 肉盾型：高生命值； 防御型：高防御； 敏捷型：低攻击间隔，共四种）、名字、等级、经验值、攻击力、防御力、生命值、攻击间隔等（以上属性必须，其他属性可自行添加）（基本要求：本游戏中只有上面的4种类型。 进一步要求：上述4种类型可以进一步深入划分，比如力量型又可以在细分为：沙瓦朗、火爆猴、腕力等）
>
> 每个精灵初始等级为1，满级15级，每当精灵升级的时候，宠物对应的属性值会有少量增加（主属性增加量相对较多）
>
> 每个精灵有自己独特的攻击方式，如“闪电攻击”，“火焰攻击”等等，请设计一个精灵的基类，并将精灵的攻击方法设为虚方法以方便子类重写
>
> 请写一个测试程序对设计的精灵类的相关属性和方法（包括攻击函数，升级函数等）进行测试
>
> 题目考察点：类的继承，对象数据成员设计，成员函数设计 

###  题目二：用户注册与平台登录

>  每个用户需要注册一个账号，用户名全局唯一，不能有任何两个用户名相同，要考虑注册失败的场景时的反馈
>
> 实现**注册**、**登录**、**登出功能（保存）**，均采用C/S模式，客户端和服务端用socket进行通信，服务端保存所有用户的信息（文件存储或数据库均可，数据库有额外加分）
>
>  每个用户拥有：用户名、拥有的精灵，两个属性。 用户注册成功时，**系统自动随机分发三个1级精灵给用户**
>
> **用户可以查看所有成功注册用户拥有的精灵，也可以查看所有当前在线的用户**
>
> 如有界面设计可酌情加分
>
> 题目考察点：socket通信，交互场景反馈 

### 题目三：游戏对战的设计

> 已经登录的在线用户可以和服务器进行虚拟决斗，决斗分两种：升级赛和决斗赛，两种比赛都能增长宠物经验值。服务器上有一个虚拟精灵的列表，用户可以挑选其中任意一个进行比赛（升级赛或者决斗赛）。另外决斗赛中用户胜出可以直接获得该战胜的的精灵，失败则系统从用户的精灵中随机选三个（不够三个精灵的情况就选择他所有的精灵），然后由用户选一个送出。
>
> 升级赛 只是用户用来增加精灵经验值，规则开发者自定；
>
> n  累积多少经验值升一级，规则开发者自定；
>
> n  决斗赛的上述规则同升级赛，只是额外还可以赢得宠物一个。
>
> 用户如果没有精灵（比如总是失败，已经全部送出去），则系统会随机放给给他一个初级精灵。
>
> 请让你的系统自动模拟每场比赛的每次出招。另外，为了增加不确定性，可以加入概率闪避攻击和暴击伤害机制
>
> 比赛的过程和结果由系统根据上述规则自动模拟完成，要求结果具有一定的随机性。
>
> 用户增加新功能，可以查看某个用户的胜率
>
> 用户增加新属性，为宠物个数徽章（金银铜）和高级宠物徽章（金银铜），分别根据拥有的宠物个数的多少和拥有高级宠物（15级）个数的多少颁发
>
> 如有界面设计可酌情加分，如有新颖设计可酌情加分
>
> 题目考察点：客户端与服务器数据交互（可采用多进程或异步通信或其他方法均可），并发请求处理，类的方法设计，伤害计算方法设计。



## 二、结构设计

### 题目一

```c++
class bullet//法球类，用于传递攻击方信息
{
public:
    bullet();
    bullet(const bullet &sample);
    void operator=(const bullet &sample);

    int total_damage;//基础伤害
    int element_damage;//属性异常状态
    int element;//攻击属性
};
```

#### 基类设计

```c++
class my_pokemon : public QObject
{
    Q_OBJECT
public:
    my_pokemon();
    int get_speed();//获取速度
    int get_hp();//获取当前血量
    int get_total_hp();//获取满血血量
    QString get_name();//获取名字
    int get_remaining_pp();//获取剩余技能
    int get_status();//获取精灵状态
    void rename(QString new_name);//精灵重命名
    int get_num();//获取精灵的唯一标识
    int get_id();//获取精灵种类（例：皮卡丘）
    int get_level();//获取等级
    int get_exp();//获取经验
    int get_power();//获取攻击力
    int get_defence();//获取防御力
    QString get_skillname();//获取技能名称
    
    void if_level_up();//是否能够升级
    bullet* attack();//普通攻击
    virtual bullet* skill() = 0;//使用技能（纯虚函数）
    bool hit(bullet*);//受到攻击
    void hp_recover(double);//使用回复药
    void debuff_recover();//恢复异常状态
    void recover();//完全恢复
    void print();//输出精灵信息（用于调试）
    int deal_with_debuff();//处理异常状态
    void get_exp(int);//获取经验值
    void hp1()//从0回复到1点血（用于战败后恢复）
    my_pkm_container to_pkmcontainer();//转换为容器类（用于传递，密封性差）

protected:
	void level_up_for_all();//所有精灵通用的升级处理
    virtual void level_up() = 0;//升级（由于各种类型的精灵成长不同，故在主类中实现）
    int num;//精灵的唯一标识
    int id;//精灵种类
    QString name;
    int attribute;//精灵类别
    int element;//精灵属性
    int level;//等级
    int exp;//经验
    int remaining_hp;//当前血量
    int total_hp;//总血量
    int power;//攻击力
    int defence;//防御力
    int attack_interval;//攻击间隔
    int status;//精灵状态（是否属性异常）
    int remaining_chaos_time;//状态异常剩余时间
    int total_pp;//技能使用次数
    int remaining_pp;//剩余技能使用次数
    int total_power;//用于恢复到原攻击力
    int total_defence;//用于恢复到原防御力
    QString skill_name;//技能名称

signals:
    void insert_log(QString);//发送战斗日志
    void lv_up(int);//升级信号
};
```

#### 主类设计

```c++
/*主类
直接继承自基类
*/
//敏捷型
class my_Speed : public my_pokemon
{
public:
    my_Speed();//各类型精灵初始属性不同，在构造函数中实现

protected:
    void level_up();//升级函数实现
};

//攻击型
class my_Attack : public my_pokemon
{
public:
    my_Attack();

protected:
    void level_up();
};

//防御性
class my_Defence : public my_pokemon
{
public:
    my_Defence();

protected:
    void level_up();
};

//肉盾型
class my_Tank : public my_pokemon
{
public:
    my_Tank();

protected:
    void level_up();
};
```

#### 具体精灵实现

```c++
//皮卡丘
class my_Pikachu : public my_Speed
{
public:
    bullet* skill();//使用技能
    my_Pikachu(int level);//生成对应等级的皮卡丘
    my_Pikachu(int, int, QString, int, int, int, int, int, int);//参数依次为num，id，name，level，exp，hp，power，defence，attack_interval，用于通过从服务器获取精灵信息生成对应精灵
};

//小火龙
class my_Hitokage : public my_Attack
{
public:
    bullet* skill();
    my_Hitokage(int level);
    my_Hitokage(int, int, QString, int, int, int, int, int, int);
};

//杰尼龟
class my_Zenigame : public my_Attack
{
public:
    bullet* skill();
    my_Zenigame(int level);
    my_Zenigame(int, int, QString, int, int, int, int, int, int);
};

//妙蛙种子
class my_Fushigidane : public my_Tank
{
public:
    bullet* skill();
    my_Fushigidane(int level);
    my_Fushigidane(int, int, QString, int, int, int, int, int, int);
};

//白海狮
class my_Dewgong : public my_Tank
{
public:
    bullet* skill();
    my_Dewgong(int level);
    my_Dewgong(int, int, QString, int, int, int, int, int, int);
};

//大舌头
class my_Peroringa : public my_Defence
{
public:
    bullet* skill();
    my_Peroringa(int level);
    my_Peroringa(int, int, QString, int, int, int, int, int, int);
};
```

#### 容器类

用于存储从服务器获取精灵信息，并传递到对应模块用于生成对应精灵

```c++
class my_pkm_container
{
public:
    my_pkm_container();
    my_pkm_container(int, int, QString, int, int, int, int, int, int);//参数依次为num，id，name，level，exp，hp，power，defence，attack_interval，用于通过从服务器获取精灵信息生成对应精灵
    my_pkm_container(const my_pkm_container &);
    my_pkm_container operator=(const my_pkm_container &);
    QByteArray toByteArray();//把精灵信息转换为报文用于发送
    void print();

    int num;//精灵的唯一标识
    int id;//精灵种类
    QString name;//精灵名称
    int attribute;//精灵类别
    int element;//精灵属性
    int level;//等级
    int exp;//经验

    int total_hp;//满血血量
    int remaining_hp;//当前血量
    int power;//攻击力
    int defence;//防御力
    int attack_interval;//攻击间隔
    int status;//精灵状态（是否属性异常）
    int remaining_chaos_time;//状态异常剩余时间
    int total_pp;//技能使用次数
    int remaining_pp;//剩余技能使用次数
    int total_power;//用于恢复到原攻击力
    int total_defence;//用于恢复到原防御力
    QString skill_name;//技能名称
};
```



### 题目二

分为Pokemon（即Client端）和Server两部分

#### Pokemon//客户端

![](C:\Users\dell1\Desktop\Pokemon结构.png)

```c++
class MainWindow : public QMainWindow
{
    Q_OBJECT
private:
    Ui::MainWindow *ui;
    myuser *user;//用户信息
    QList<my_pokemon*> pkm_list;//用户持有的精灵
    QList<my_pokemon*> server_list;//服务器精灵列表
    myserver *myserver_;//网络层
    login_widget *login_window;//登陆界面
    pokemon_center_widget *mypokemoncenter;//精灵中心界面
    user_list *user_list_;//用户列表界面
    mybackpack *backpack;//背包界面
    music_thread *my_bgm;//bgm
};
```

##### myuser//用户类

```c++
class myuser : public QObject
{
    Q_OBJECT
public:
    QString user_id;//用户名
    int win_count;//胜场
    int total_count;//总场
    int senior_pkm_medal;//高级精灵奖章:15级精灵个数
    int number_pkm_medal;//精灵个数奖章:精灵个数
    int wincount_medal;//胜场奖章:胜场数
    int primary_medicine;//伤药
    int junior_medicine;//好伤药
    int senior_medicine;//超好伤药
    int status_medicine;//状态恢复药
    int money;//钱
};
```

##### myserver_//网络层

```c++
class myserver : public QObject
{
    Q_OBJECT
private:
    QUdpSocket *mySendingSocket;//发送Socket
    QUdpSocket *myReceivingSocket;//接受Socket
    QHostAddress server_ip;//服务器地址
    quint16 send_port = 8090;//发送端口
    quint16 rece_port = 8091;//接受端口
    quint16 dest_port = 8081;//服务器端口
    QString user_id;//用户名
    QString user_password;//用户密码
};
```



#### Server//服务器端



![Server结构](C:\Users\dell1\Desktop\Server结构.png)

```c++
class myserver : public QObject
{
    Q_OBJECT
public:
    myserver();
    ~myserver(){}

private:
    QUdpSocket *mySendingSocket;//发送Socket
    QUdpSocket *myReceivingSocket;//接收Socket
    quint16 send_port = 8080;//发送端口
    quint16 rece_port = 8081;//接受端口
    mydatabase *mydatabase_;//数据库
    QList<QString> online_user;//在线用户列表

    int pkm_count;//精灵num计数
};
```

##### mydatabase

```c++
class mydatabase : public QObject
{
    Q_OBJECT
public:
    mydatabase();
    void createTable();

    bool insertUser(myuser);//插入用户
    bool getUser(QString user_id, QVector<QByteArray> &);//查询用户
    void updateUser(myuser);//更新用户信息
    QVector<QVector<QString>> get_userlist();//获取用户列表
    QVector<QVector<QString>> get_pokemonlist(QString);//获取某用户的精灵信息
    void printUserTable();//输出用户表（用于调试）

    int get_pkm_num();//更新最大精灵pkm_count
    bool insertPokemon(my_pokemon);//插入精灵
    void updatePokemon(my_pokemon);//更新精灵
    void deletePokemon(int);//删除精灵
    QVector<QString> getPokemon(QString);//查询精灵
    void printPkmTable();//输出精灵表（用于调试）

private:

    QSqlDatabase db;
    QString create_user_tbl = "create table if not exists user  (user_id varchar(30) primary key, "
                              "user_password varchar(30), "
                              "win_count int, "
                              "total_count int, "
                              "senior_pkm_medal int, "
                              "number_pkm_medal int, "
                              "wincount_medal int, "
                              "primary_medicine int, "
                              "junior_medicine int, "
                              "senior_medicine int, "
                              "status_medicine int, "
                              "money int)";
    QString insert_user_tbl = "insert into user values(?,?,?,?,?,?,?,?,?,?,?,?)";
    QString select_all_user_tbl = "select * from user";

    QString create_pkm_tbl = "create table if not exists pkm (num int primary key, "
                             "id int, "
                             "name varchar(30), "
                             "level int, exp int, "
                             "hp int, "
                             "power int, "
                             "defence int, "
                             "attack_interval int, "
                             "user_id varchar(30))";
    QString insert_pkm_tbl = "insert into pkm values(?,?,?,?,?,?,?,?,?,?)";
    QString select_all_pokemon_tbl = "select * from pkm";
};
```

### 题目三

#### battle_ground//道馆

![battle_ground](C:\Users\dell1\Desktop\battle_ground.png)

```c++
class battle_ground : public QWidget
{
    Q_OBJECT

public:
    explicit battle_ground(QWidget *parent = nullptr);
    void show_battleground(QList<my_pokemon*>*, QList<my_pokemon*>*, myuser*);
    ~battle_ground();

private:
    Ui::battle_ground *ui;
    battle_field *mybattlefield;//战斗界面
    QList<my_pokemon*> *pkm_list;//用户精灵列表
    QList<my_pokemon*> *server_list;//服务器精灵列表
    myuser *user;//用户信息
    QStandardItemModel *model1;
    QStandardItemModel *model2;
    my_pokemon* p1;//用户选择的己方精灵
    my_pokemon* p2;//用户选择的对方精灵
    int is_auto = 0;//是否自动战斗

    //获得3个int范围内不相同的随机数
    QList<int> get_random_num(int);

```

##### battle_field//战斗界面

```c++
class battle_field : public QWidget
{
    Q_OBJECT
private:
    Ui::battle_field *ui;
    my_pokemon* p1;//己方精灵
    my_pokemon* p2;//对方精灵
    myuser *user;//用户信息
    int p1_interval;//己方累积攻击间隔
    int p2_interval;//对方累积攻击间隔
    bool is_auto = 0;//是否自动战斗
    int battletype;//正在进行的战斗类型
    int result;//战斗结果
}
```



## 三、具体实现

对于UI显示方面的内容会被略过，此处着重体现主要功能的实现

### 题目一

题目一中完成的精灵类在题目二和三中有部分微调（如调整成中文输出，部分数值的变化），更加详细的注释解析也可以在后两版中查看。

- 精灵的构造（由于Qt会自动释放已关闭控件的内存，且成员中没有指针，可以直接自动析构，故没有特意写析构函数）

  > 每个具体精灵的实现都会调用基类、主类和自己的构造函数。基类的构造函数初始化所有精灵通用的属性；主类的构造函数初始化本类别的精灵的特殊数值；其余的实现则取决于该类型本身，是其独有的属性。此处以皮卡丘为例。
  >
  > ```c++
  > my_pokemon::my_pokemon()
  > {
  >     this->level = 1;
  >     this->exp = 0;
  >     this->status = NORMAL;
  >     this->remaining_chaos_time = 0;
  > }
  > ```
  >
  > ```c++
  > my_Speed::my_Speed()
  > {
  >     this->attribute = SPEED;
  >     this->total_hp = 300;
  >     this->remaining_hp = this->total_hp;
  >     this->total_power = 30;
  >     this->total_defence = 30;
  >     this->power = this->total_power;
  >     this->defence = this->total_defence;
  >     this->attack_interval = 400;
  > }
  > ```
  >
  > ```c++
  > my_Pikachu::my_Pikachu(int level)
  > {
  >     this->id = 1;
  >     this->name = "Pikachu";
  >     this->element = ELECTRICITY;
  >     this->total_pp = 15;
  >     this->remaining_pp = this->total_pp;
  >     this->skill_name = "十万伏特";
  > 
  >     this->exp = (level - 1)*(level - 1)*(level - 1);
  >     if_level_up();
  > }
  > ```

- 精灵的攻击和技能以及受击

  > 普通攻击函数是所有精灵通用的
  >
  > ```c++
  > bullet* my_pokemon::attack()//普通攻击
  > {
  >     bullet *bul = new bullet;
  >     bul->element = NORMAL;
  >     bul->element_damage = NORMAL;
  >     bul->total_damage = ((this->level * 3 + 3)*this->power + 10) * 3 / 2;
  > 
  >     //普通攻击有概率暴击
  >     if (random_num_generator(p_critical))
  >     {
  >         bul->element = CRITICAL;
  >     }
  >     QString log;
  >     log = "%1 使出了普通攻击\n";
  >     emit insert_log(log.arg(this->name));
  >     return bul;
  > }
  > ```
  >
  > 该函数返回一个bullet类，存储此次攻击的伤害及属性，其中total_damage由精灵等级和攻击力共同决定；element为NORMAL，若造成了暴击则为CRITICAL；element_damage默认为NORMAL。

  > 技能函数由每个精灵类具体实现，此处以皮卡丘的技能为例
  >
  > ```c++
  > bullet* my_Pikachu::skill()
  > {
  >     QString log;
  >     log = "%1 使用了 %2 ";
  >     emit insert_log(log.arg(this->name).arg(this->skill_name));
  > 
  >     this->remaining_pp--;
  >     bullet *bul = new bullet;
  >     bul->element = this->element;
  >     bul->total_damage = (this->level * 3.5 + 2)*this->power + 2;
  >     bul->total_damage *= 1.5;//用于调节平衡性
  >     if (random_num_generator(p_paralyze))
  >         bul->element_damage = this->element;
  >     else
  >         bul->element_damage = NORMAL;
  >     return bul;
  > }
  > ```
  >
  > 该函数返回一个bullet类，存储此次技能的伤害及属性，其中total_damage由精灵等级和攻击力共同决定；element与精灵属性相同，不会造成暴击；有一定概率会给对方附加麻痹、灼伤、溺水属性异常（视使用的技能而定），表现在element_damage上。

  > 受击函数是所有精灵通用的，会接受攻击方的产生的bullet，进行伤害结算。
  >
  > ```c++
  > bool my_pokemon::hit(bullet *bul)
  > {
  >     int hurt;
  >     QString log;
  >     //触发闪避
  >     if (random_num_generator(p_evade))
  >     {
  >         log = "%1 闪避了\n";
  >         emit insert_log(log.arg(this->name));
  >         hurt = 0;
  >         return false;
  >     }
  > 
  >     hurt = (bul->total_damage / this->defence)*counter_talbe[bul->element][this->element];
  >     QString debug = "hurt=(%1 // %2)*%3";
  >     if (bul->element == CRITICAL)
  >     {
  >         log = "会心一击，%1 受到了 %2 伤害\n";
  >         emit insert_log(log.arg(this->name).arg(hurt));
  >     }
  >     else if(counter_talbe[bul->element][this->element]==2)
  >     {
  >         log = "效果拔群，%1 受到了 %2 伤害\n";
  >         emit insert_log(log.arg(this->name).arg(hurt));
  >     }
  >     else if(counter_talbe[bul->element][this->element]==0.5)
  >     {
  >         log = "效果不理想，%1 受到了 %2 伤害\n";
  >         emit insert_log(log.arg(this->name).arg(hurt));
  >     }
  >     else
  >     {
  >         log = "%1 受到了 %2 伤害\n";
  >         emit insert_log(log.arg(this->name).arg(hurt));
  >     }
  > 
  >     if(bul->element_damage!=NORMAL&&bul->element_damage!=CRITICAL)
  >     {
  >         switch (bul->element_damage)
  >         {
  >         case FIRE:
  >             log = "%1 灼伤了\n";
  >             emit insert_log(log.arg(this->name));
  >             break;
  > 
  >         case WATER:
  >             log = "%1 溺水了\n";
  >             emit insert_log(log.arg(this->name));
  >             break;
  > 
  >         case ELECTRICITY:
  >             log = "%1 麻痹了\n";
  >             emit insert_log(log.arg(this->name));
  >             break;
  >         }
  >         this->remaining_chaos_time = 3;
  >         this->status = bul->element_damage;
  >     }
  > 
  >     if (hurt >= this->remaining_hp)
  >     {
  >         this->remaining_hp = 0;
  >         return true;//表示血量为0，失败
  >     }
  >     else
  >     {
  >         this->remaining_hp -= hurt;
  >         return false;
  >     }
  > }
  > ```
  >
  > 攻击和技能有一定概率被闪避；根据bullet的element和受击精灵属性的克制关系，伤害会有2倍/1倍/0.5倍三种情况；根据bullet的element_damage，给受击方施加属性异常状态。若受击方血量为0，则返回true；否则返回false。

- 异常状态处理

  > 每回合开始时调用此函数，若精灵状态不为NORMAL，则进行异常状态处理。
  >
  > ```c++
  > int my_pokemon::deal_with_debuff()
  > {
  >     //异常状态的恢复
  >     QString log;
  >     if (this->status == NORMAL)
  >         return false;
  >     //若已超过异常时间
  >     if (remaining_chaos_time == 0 && this->status!=NORMAL)
  >     {
  >         //恢复降低的属性
  >         if (this->status == WATER)
  >         {
  >             this->power = this->total_power;
  >             this->defence = this->total_defence;
  >         }
  >         this->status = NORMAL;
  >         log = "%1 的异常状态恢复了";
  >         emit insert_log(log.arg(this->name));
  >         return false;
  >     }
  >     int debuff;
  >     int debuff_power;
  >     int debuff_defence;
  >     switch (this->status)
  >     {
  >     case ELECTRICITY:
  >         log = "%1 受到麻痹异常状态影响，无法行动，异常状态还有 %2 回合\n";
  >         emit insert_log(log.arg(this->name).arg(this->remaining_chaos_time));
  >         break;
  > 
  >     case FIRE:
  >         debuff = 0.05*total_hp + 1;
  >         log = "%1 受到灼伤异常状态影响，血量持续减少 ，异常状态还有 %2 回合\n";
  >         emit insert_log(log.arg(this->name).arg(this->remaining_chaos_time));
  >         if (remaining_hp > debuff)
  >         {
  >             remaining_hp -= debuff;
  >             log = "血量减少 %1";
  >             emit insert_log(log.arg(debuff));
  >         }
  >         else
  >         {
  >             remaining_hp = 0;
  >             log = "血量减少为0";
  >             emit insert_log(log);
  >             return true;
  >         }
  >         break;
  > 
  >     case WATER:
  >         log = "%1 受到溺水异常状态影响，攻击力防御力降低，异常状态还有 %2 回合\n";
  >         emit insert_log(log);
  >         debuff_power = power*0.2;
  >         debuff_defence = defence*0.2;
  >         if (remaining_chaos_time == 3)
  >         {
  >             this->power -= debuff_power;
  >             this->defence -= debuff_defence;
  >             log = "攻击力降低 %1，防御力降低 %2\n";
  >             insert_log(log.arg(debuff_power).arg(debuff_defence));
  >         }
  >         break;
  >     }
  >     this->remaining_chaos_time--;
  >     return false;
  > }
  > ```
  >
  > 若精灵血量为0则返回true，否则返回false。若精灵状态为NORMAL状态则直接返回false；若精灵状态为灼伤，则扣除精灵血量；若精灵状态为溺水，则在第一次异常状态处理时减少攻击力和防御力，后续回合不会持续减少，并在异常状态时间结束后回复攻击力和防御力数值；麻痹在此处只返回log，具体效果是使受击精灵3回合内不能行动，会在battle_field中实现。

- 升级

  > 结算时先分配经验值，再调用if_level_up()函数判断经验值是否足够升级，若足够升级则调用level_up()
  >
  > ```c++
  > void my_pokemon::if_level_up()
  > {
  >     if (this->level < 15)
  >         if (level*level*level <= this->exp)
  >         {
  >             emit lv_up(this->level);
  >             level_up();
  >         }
  > }
  > ```

  > 每个主类的精灵成长不同，故升级函数不同，此处以攻击型精灵为例
  >
  > ```c++
  > void my_Attack::level_up()
  > {
  >     this->total_power += (5 * (1 + random_num_generator(0.1)));
  >     this->total_defence += (3 * (1 + random_num_generator(0.1)));
  >     this->attack_interval -= (2 * (1 + random_num_generator(0.1)));
  >     this->total_hp += (10 * (1 + random_num_generator(0.1)));
  >     this->level_up_for_all();
  >     if_level_up();
  > }
  > ```

  > level_up_for_all()为每个类型的精灵通用的升级函数
  >
  > ```c++
  > void my_pokemon::level_up_for_all()
  > {
  >     this->level++;
  >     this->remaining_hp = this->total_hp;
  >     this->remaining_pp = this->total_pp;
  >     this->power = this->total_power;
  >     this->defence = this->total_defence;
  >     this->status = NORMAL;
  >     this->remaining_chaos_time = 0;
  > }
  > ```

  **测试程序**

  > ![1546347347420](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546347347420.png)


### 题目二

#### Pokemon（客户端）

- myserver

  > myserver是网络层，用于客户端与服务器间的通信，我采用了UDP通信的方式。网络层通过套接字，以QByteArray的形式传递报文，报文开头为报文类型，表示此报文的目的，每一项内容以";"隔开，接收方根据报文类型还原出数据，并作出相应处理。

  > 相关定义
  >
  > ```c++
  > #define GET_SERVER_IP 0//获取服务器ip
  > #define LOGIN 1//登录
  > #define REGISTER 2//注册
  > #define GET_USERS 3//获取用户列表
  > #define GET_POKEMONLIST 4//获取某用户的精灵信息
  > #define EXIT 5//退出
  > #define UPDATE_PKM 6//增删改精灵信息
  > #define REFRESH_MY_POKEMON 7//获取自己的精灵信息
  > #define UPDATE_USER_INFO 8//更新用户信息
  > #define INIT_MY_USER 9//获取自己的用户信息
  > #define GET_SERVER_PKM 10//获取服务器精灵列表
  > 
  > #define LOGIN_SUCCESSFUL 0//登录成功
  > #define LOGIN_NO_USER 1//用户不存在
  > #define LOGIN_WRONG_PASSWORD 2//密码错误
  > 
  > #define REGIST_SUCCESSFUL 0//注册成功
  > #define REGIST_EXIST 1//用户已存在
  > #define REGIST_FAILED 2//注册失败
  > 
  > #define OFFLINE 0//在线
  > #define ONLINE 1//不在线
  > 
  > #define NEW_PKM 0//增加精灵
  > #define CHANGE_PKM 1//更新精灵
  > #define DELETE_PKM 2//删除精灵
  > ```

  > 构造函数，从8090和8091开始尝试绑定端口，若失败则向后顺延两位，直到两个端口同时绑定为止。
  >
  > ```c++
  > myserver::myserver()
  > {
  >     mySendingSocket = new QUdpSocket;
  >     myReceivingSocket = new QUdpSocket;
  >     while(!mySendingSocket->bind(send_port,QUdpSocket::DontShareAddress)|| \
  >           !myReceivingSocket->bind(rece_port,QUdpSocket::DontShareAddress))
  >     {
  >         send_port += 2;
  >         rece_port += 2;
  >     }
  >     connect(this->myReceivingSocket,SIGNAL(readyRead()),this,SLOT(receive_data()));
  >     get_server_address();
  > }
  > ```
  >
  > 获取服务器ip，广播以获取服务器ip
  >
  > ```c++
  > void myserver::get_server_address()
  > {
  >     qDebug("get server ip");
  >     QByteArray msg = QByteArray::number(GET_SERVER_IP);
  >     mySendingSocket->writeDatagram(msg.data(), sizeof(msg), QHostAddress::Broadcast, dest_port);
  > }
  > ```
  >
  > 发送数据报
  >
  > ```c++
  > void myserver::send_data(QByteArray msg)
  > {
  >     qDebug() << "send datagram:" << msg;
  >     mySendingSocket->writeDatagram(msg.data(), server_ip, dest_port);
  > }
  > ```
  >
  > **接收数据报**
  >
  > ```c++
  > void myserver::receive_data()
  > {
  >     while(myReceivingSocket->hasPendingDatagrams())
  >     {
  >         qDebug("data received");
  > 
  >         QHostAddress server_ip;
  >         QByteArray msg;
  >         msg.resize(myReceivingSocket->pendingDatagramSize());
  >         myReceivingSocket->readDatagram(msg.data(), msg.size(), &server_ip);
  >         qDebug()<<"receive data: "<<msg;
  >         QList<QByteArray> list = msg.split(';');
  > 
  >         int manipulate = list[0].toInt();
  >         int status;
  >         QPair<QString,int> temp;
  >         QVector<QPair<QString,int>> user_list;
  >         int pkm_num;
  >         QList<int> choice;
  >         qDebug()<<manipulate;
  > 
  >         switch(manipulate)//根据报文类型选择后续操作
  >         {
  >         case GET_SERVER_IP:
  >             this->server_ip = server_ip;
  >             qDebug()<<this->server_ip;
  >             break;
  > 
  >         case LOGIN:
  >             status = list[1].toInt();
  >             switch(status)
  >             {
  >             case LOGIN_SUCCESSFUL:
  >                 emit game_login(this->user_id);
  >                 break;
  > 
  >             case LOGIN_NO_USER:
  >                 emit draw_warning("User Doesn't Exist");
  >                 break;
  > 
  >             case LOGIN_WRONG_PASSWORD:
  >                 emit draw_warning("Wrong Password");
  >                 break;
  >             }
  >             break;
  > 
  >         case REGISTER:
  >             status = list[1].toInt();
  >             switch(status)
  >             {
  >             case REGIST_SUCCESSFUL:
  >                 emit game_login(this->user_id);
  >                 emit init_pkm();
  >                 choice = init_pokemon();
  >                 for(int j=0;j<3;j++)
  >                 {
  >                     my_pkm_container tmp;//无用临时变量
  >                     update_pkm(NEW_PKM, choice[j], tmp);
  >                 }
  >                 break;
  > 
  >             case REGIST_EXIST:
  >                 emit draw_warning("User Already Exists");
  >                 break;
  > 
  >             case REGIST_FAILED:
  >                 emit draw_warning(("Register Failed"));
  >                 break;
  >             }
  >             break;
  > 
  >         case GET_USERS:
  >             list.pop_front();
  >             refresh_user_list(list);
  >             break;
  > 
  >         case GET_POKEMONLIST:
  >             if(!list[1].toInt())
  >             {
  >                 emit draw_warning("This User has no Pokemon");
  >             }
  >             else
  >             {
  >                 list.pop_front();//弹出manipulate
  >                 pkm_num = list[0].toInt();
  >                 list.pop_front();//弹出精灵个数
  >                 send_pokemonlist(list, pkm_num);
  >             }
  >             break;
  > 
  >         case REFRESH_MY_POKEMON:
  >             list.pop_front();//弹出manipulate
  >             refresh_my_pokemon(list);
  >             break;
  > 
  >         case INIT_MY_USER:
  >             list.pop_front();
  >             refresh_my_user(list);
  >             break;
  > 
  >         case GET_SERVER_PKM:
  >             list.pop_front();
  >             get_server_pkm(list);
  >             break;
  >         }
  >     }
  > }
  > ```
  >
  > 发送登录请求
  >
  > ```c++
  > void myserver::login(QString user_id, QString user_password)
  > {
  >     this->user_id = user_id;
  >     this->user_password = user_password;
  >     QByteArray msg = QByteArray::number(LOGIN);
  >     msg += ";" + user_id;
  >     msg += ";" + user_password;
  >     send_data(msg);
  > }
  > ```
  >
  > 发送注册请求
  >
  > ```c++
  > void myserver::regist(QString regist_id, QString regist_password)
  > {
  >     this->user_id = regist_id;
  >     this->user_password = regist_password;
  >     QByteArray msg = QByteArray::number(REGISTER);
  >     msg += ";" + regist_id;
  >     msg += ";" + regist_password;
  >     send_data(msg);
  > }
  > ```
  >
  > 发送下线信息
  >
  > ```c++
  > void myserver::exit()
  > {
  >     QByteArray msg;
  >     msg = QByteArray::number(EXIT);
  >     msg += ";" + user_id;
  >     qDebug()<<user_id;
  >     send_data(msg);
  > }
  > ```
  >
  > 获取用户列表
  >
  > ```c++
  > void myserver::get_users()
  > {
  >     QByteArray msg;
  >     msg = QByteArray::number(GET_USERS);
  >     send_data(msg);
  > }
  > ```
  >
  > 获取某一用户的详细精灵信息
  >
  > ```C++
  > void myserver::get_pokemonlist(QString user_id)
  > {
  >     qDebug("get_pokemonlist");
  >     QByteArray msg;
  >     msg = QByteArray::number(GET_POKEMONLIST);
  >     msg += ";" + user_id;
  >     send_data(msg);
  > }
  > ```
  >
  > 将收到的用户精灵信息发送给对应模块
  >
  > ```c++
  > void myserver::send_pokemonlist(QList<QByteArray> list, int pkm_num)
  > {
  >     qDebug()<<list;
  >     static int pkm_count = 0;
  >     pkm_count++;
  >     int num = list[0].toInt();
  >     int id = list[1].toInt();
  >     QString name = list[2];
  >     int level = list[3].toInt();
  >     int exp = list[4].toInt();
  >     int hp = list[5].toInt();
  >     int power = list[6].toInt();
  >     int defence = list[7].toInt();
  >     int attack_interval = list[8].toInt();
  >     my_pkm_container pokemon(num, id, name, level, exp, hp, power, defence, attack_interval);
  >     pkm_buffer.append(pokemon);
  >     if(pkm_num==pkm_count)
  >     {
  >         emit send_pokemon(pkm_buffer);
  >         pkm_buffer.clear();
  >         pkm_count = 0;
  >     }
  > }
  > ```
  >
  > 向服务器更新、删除、增加精灵
  >
  > ```c++
  > void myserver::update_pkm(int manipulate, int id, my_pkm_container pkm)//id表示新添加的精灵的id
  > {
  >     QByteArray msg = QByteArray::number(UPDATE_PKM);
  >     switch(manipulate)
  >     {
  >     case NEW_PKM:
  >         msg += ";" + QByteArray::number(NEW_PKM);
  >         msg += ";" + QByteArray::number(id);
  >         msg += ";" + user_id;
  >         break;
  > 
  >     case CHANGE_PKM:
  >         msg += ";" + QByteArray::number(CHANGE_PKM);
  >         pkm.print();
  >         msg += ";" + pkm.toByteArray();
  >         msg += ";" + user_id;
  >         break;
  > 
  >     case DELETE_PKM:
  >         msg += ";" + QByteArray::number(DELETE_PKM);
  >         msg += ";" + QByteArray::number(pkm.num);
  >         msg += ";" + user_id;
  >     }
  >     send_data(msg);
  > }
  > ```
  >
  > 向服务器获取3只初始精灵
  >
  > ```c++
  > QList<int> myserver::init_pokemon()
  > {
  >     int pkm[3] = {0, 0, 0};
  >     pkm[0] = rand() % 6 + 1;
  >     int temp;
  >     while(!(pkm[1]&&pkm[2]))
  >     {
  >         temp = rand() % 6 + 1;
  >         if(!pkm[1])
  >             if(temp==pkm[0])
  >                 continue;
  >             else
  >                 pkm[1] = temp;
  >         else
  >             if(temp==pkm[0]||temp==pkm[1])
  >                 continue;
  >             else
  >                 pkm[2] = temp;
  >     }
  >     QList<int> list;
  >     list.append(pkm[0]);
  >     list.append(pkm[1]);
  >     list.append(pkm[2]);
  >     qDebug()<<list;
  >     return list;
  > }
  > ```
  >
  > 用收到的数据更新自己的精灵信息
  >
  > ```c++
  > void myserver::refresh_my_pokemon(QList<QByteArray> list)
  > {
  >     my_pokemon *temp;
  >     int num = list[0].toInt();
  >     int id = list[1].toInt();
  >     QString name = list[2];
  >     int level = list[3].toInt();
  >     int exp = list[4].toInt();
  >     int hp = list[5].toInt();
  >     int power = list[6].toInt();
  >     int defence = list[7].toInt();
  >     int attack_interval = list[8].toInt();
  >     switch(id)
  >     {
  >     case PIKACHU:
  >         temp = new my_Pikachu(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case HITOKAGE:
  >         temp = new my_Hitokage(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case ZENIGAME:
  >         temp = new my_Zenigame(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case FUSHIGIDANE:
  >         temp = new my_Fushigidane(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case DEWGONG:
  >         temp = new my_Dewgong(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case PERORINGA:
  >         temp = new my_Peroringa(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  >     }
  >     emit refresh_pokemon(temp);
  > }
  > ```
  >
  > 获取用户信息
  >
  > ```c++
  > void myserver::init_my_user()
  > {
  >     QByteArray msg;
  >     msg = QByteArray::number(INIT_MY_USER);
  >     msg += ";" + user_id;
  >     send_data(msg);
  > }
  > ```
  >
  > 用获取的数据更新本地用户信息
  >
  > ```c++
  > void myserver::refresh_my_user(QList<QByteArray> list)
  > {
  >     myuser user;
  >     user.user_id = list[0];
  >     user.win_count = list[1].toInt();
  >     user.total_count = list[2].toInt();
  >     user.senior_pkm_medal = list[3].toInt();
  >     user.number_pkm_medal = list[4].toInt();
  >     user.wincount_medal = list[5].toInt();
  >     user.primary_medicine = list[6].toInt();
  >     user.junior_medicine = list[7].toInt();
  >     user.senior_medicine = list[8].toInt();
  >     user.status_medicine = list[9].toInt();
  >     user.money = list[10].toInt();
  >     emit init_user(user);
  > }
  > ```
  >
  > 更新用户信息
  >
  > ```c++
  > void myserver::update_user_info(myuser user)
  > {
  >     QByteArray msg;
  >     msg = QByteArray::number(UPDATE_USER_INFO);
  >     msg += ";" + user.user_id;
  >     msg += ";" + QByteArray::number(user.win_count);
  >     msg += ";" + QByteArray::number(user.total_count);
  >     msg += ";" + QByteArray::number(user.senior_pkm_medal);
  >     msg += ";" + QByteArray::number(user.number_pkm_medal);
  >     msg += ";" + QByteArray::number(user.wincount_medal);
  >     msg += ";" + QByteArray::number(user.primary_medicine);
  >     msg += ";" + QByteArray::number(user.junior_medicine);
  >     msg += ";" + QByteArray::number(user.senior_medicine);
  >     msg += ";" + QByteArray::number(user.status_medicine);
  >     msg += ";" + QByteArray::number(user.money);
  >     send_data(msg);
  > }
  > ```
  >
  > 获取用户列表
  >
  > ```c++
  > void myserver::refresh_user_list(QList<QByteArray> msg)
  > {
  >     QVector<myuser> user_list;
  >     QVector<int> online_status;
  >     while(msg.size())
  >     {
  >         myuser temp;
  >         temp.user_id = msg[0];
  >         msg.pop_front();
  >         temp.win_count = msg[0].toInt();
  >         msg.pop_front();
  >         temp.total_count = msg[0].toInt();
  >         msg.pop_front();
  >         temp.senior_pkm_medal = msg[0].toInt();
  >         msg.pop_front();
  >         temp.number_pkm_medal = msg[0].toInt();
  >         msg.pop_front();
  >         temp.wincount_medal = msg[0].toInt();
  >         msg.pop_front();
  >         user_list.append(temp);
  > 
  >         online_status.append(msg[0].toInt());
  >         msg.pop_front();
  >     }
  >     emit send_user_list(user_list, online_status);
  > }
  > ```
  >
  > 获取服务器精灵列表
  >
  > ```c++
  > void myserver::init_server_pkm()
  > {
  >     QByteArray msg;
  >     msg = QByteArray::number(GET_SERVER_PKM);
  >     send_data(msg);
  > }
  > ```
  >
  > 用收到的数据更新本地服务器精灵列表
  >
  > ```c++
  > void myserver::get_server_pkm(QList<QByteArray> list)
  > {
  >     my_pokemon *temp;
  >     int num = list[0].toInt();
  >     int id = list[1].toInt();
  >     QString name = list[2];
  >     int level = list[3].toInt();
  >     int exp = list[4].toInt();
  >     int hp = list[5].toInt();
  >     int power = list[6].toInt();
  >     int defence = list[7].toInt();
  >     int attack_interval = list[8].toInt();
  >     switch(id)
  >     {
  >     case PIKACHU:
  >         temp = new my_Pikachu(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case HITOKAGE:
  >         temp = new my_Hitokage(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case ZENIGAME:
  >         temp = new my_Zenigame(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case FUSHIGIDANE:
  >         temp = new my_Fushigidane(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case DEWGONG:
  >         temp = new my_Dewgong(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  > 
  >     case PERORINGA:
  >         temp = new my_Peroringa(num, id, name, level, exp, hp, power, defence, attack_interval);
  >         break;
  >     }
  >     emit send_server_pkm(temp);
  > }
  > ```

#### Server（服务器端）

- myserver

  > 服务器端网络层接受客户发来的请求并作出相应回应

  > 相关定义与客户端相同
  >
  > ```c++
  > #define GET_SERVER_IP 0//获取服务器ip
  > #define LOGIN 1//登录
  > #define REGISTER 2//注册
  > #define GET_USERS 3//获取用户列表
  > #define GET_POKEMONLIST 4//获取某用户的精灵信息
  > #define EXIT 5//退出
  > #define UPDATE_PKM 6//增删改精灵信息
  > #define REFRESH_MY_POKEMON 7//获取自己的精灵信息
  > #define UPDATE_USER_INFO 8//更新用户信息
  > #define INIT_MY_USER 9//获取自己的用户信息
  > #define GET_SERVER_PKM 10//获取服务器精灵列表
  > 
  > #define LOGIN_SUCCESSFUL 0//登录成功
  > #define LOGIN_NO_USER 1//用户不存在
  > #define LOGIN_WRONG_PASSWORD 2//密码错误
  > 
  > #define REGIST_SUCCESSFUL 0//注册成功
  > #define REGIST_EXIST 1//用户已存在
  > #define REGIST_FAILED 2//注册失败
  > 
  > #define OFFLINE 0//在线
  > #define ONLINE 1//不在线
  > 
  > #define NEW_PKM 0//增加精灵
  > #define CHANGE_PKM 1//更新精灵
  > #define DELETE_PKM 2//删除精灵
  > ```

  > 发送报文
  >
  > ```c++
  > void myserver::send_data(QByteArray msg, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     qDebug()<<"data sent:" << msg;
  >     mySendingSocket->writeDatagram(msg, sender_ip, sender_port);
  > }
  > ```
  >
  > 发送空报文以提供服务器ip
  >
  > ```c++
  > void myserver::send_ip(QHostAddress sender_ip, quint16 sender_port)
  > {
  >     QByteArray msg;
  >     msg = QString::number(GET_SERVER_IP).toUtf8();
  >     send_data(msg, sender_ip, sender_port);
  > }
  > ```
  >
  > 处理用户登录，返回值为登录结果
  >
  > ```c++
  > bool myserver::login(QString user_id, QString user_password, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     bool ok = false;
  >     QVector<QByteArray> user;
  >     QByteArray msg;
  >     msg = QString::number(LOGIN).toUtf8();
  >     msg += ";";
  >     if(mydatabase_->getUser(user_id, user))
  >     {
  >         qDebug()<<user;
  >         //用户存在
  >         if(user.at(1) == user_password)
  >         {
  >             //密码正确
  >             refresh_online_user(user_id, ONLINE);//更新在线用户
  >             msg += QString::number(LOGIN_SUCCESSFUL);
  >             ok = true;
  >         }
  >         else
  >         {
  >             //密码不正确
  >             msg += QString::number(LOGIN_WRONG_PASSWORD);
  >         }
  >     }
  >     else
  >     {
  >         //用户不存在
  >         msg += QString::number(LOGIN_NO_USER);
  >     }
  >     send_data(msg, sender_ip, sender_port);
  >     return ok;
  > }
  > ```
  >
  > 处理用户注册
  >
  > ```c++
  > void myserver::regist(QString user_id, QString user_password, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     myuser user;
  >     QVector<QByteArray> temp;
  >     QByteArray msg;
  >     msg = QByteArray::number(REGISTER);
  >     msg += ";";
  >     if(mydatabase_->getUser(user_id, temp))
  >     {
  >         //用户已存在
  >         msg += QByteArray::number(REGIST_EXIST);
  >     }
  >     else
  >     {
  >         user.user_id = user_id;
  >         user.user_password = user_password;
  >         user.money = 2000;//金币数量初始化为2000
  >         if(mydatabase_->insertUser(user))
  >         {
  >             //插入用户成功
  >             refresh_online_user(user_id, ONLINE);//更新在线用户
  >             msg += QByteArray::number(REGIST_SUCCESSFUL);
  >         }
  >         else//插入用户失败
  >             msg += QByteArray::number(REGIST_FAILED);
  >     }
  >     send_data(msg, sender_ip, sender_port);
  > }
  > ```
  >
  > 更新在线用户列表
  >
  > ```c++
  > void myserver::refresh_online_user(QString user_id, int status)
  > {
  >     if(status==ONLINE)
  >     {
  >         if(online_user.count(user_id)==0)
  >             online_user.append(user_id);
  >     }
  >     else
  >     {
  >         online_user.removeOne(user_id);
  >     }
  > }
  > ```
  >
  > 获取用户列表
  >
  > ```c++
  > void myserver::send_userlist(QVector<QVector<QString>> user_list, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     QByteArray msg = QByteArray::number(GET_USERS);
  >     for(int i=0;i < user_list.size();i++)
  >     {
  >         msg += ";" + user_list[i][0];
  >         for(int j=1;j<6;j++)
  >             msg += ";" + user_list[i][j];
  >         if(online_user.count(user_list[i][0]))
  >             msg += ";" + QByteArray::number(ONLINE);
  >         else
  >             msg += ";" + QByteArray::number(OFFLINE);
  >     }
  >     send_data(msg, sender_ip, sender_port);
  > }
  > ```
  >
  > 获取某用户的精灵信息
  >
  > ```c++
  > void myserver::send_pokemonlist(QVector<QVector<QString>> pokemon_list, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     if(pokemon_list.size())
  >         for(int j=0;j<pokemon_list.size();j++)
  >         {
  >             QByteArray msg;
  >             msg = QByteArray::number(GET_POKEMONLIST);
  >             msg += ";" + QByteArray::number(pokemon_list.size());//该用户的精灵数量,以便客户端确认是否接受完毕
  >             for(int i=0;i<pokemon_list.at(j).size();i++)
  >             {
  >                 msg += ";" + pokemon_list.at(j).at(i);
  >             }
  >             send_data(msg, sender_ip, sender_port);
  >         }
  >     else
  >     {
  >         QByteArray msg;
  >         msg = QByteArray::number(GET_POKEMONLIST);
  >         msg += ";" + QByteArray::number(0);
  >         send_data(msg, sender_ip, sender_port);
  >     }
  > }
  > ```
  >
  > 为用户增加精灵
  >
  > ```c++
  > //为用户增加精灵
  > void myserver::new_pkm(QList<QByteArray> list, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     //插入精灵
  >     int id = list[0].toInt();
  >     QString user_id = list[1];
  >     my_pokemon pkm(id, ++pkm_count, user_id);//根据精灵id生成一只1级的对应精灵
  >     mydatabase_->insertPokemon(pkm);
  >     //返回精灵
  >     QByteArray msg = QByteArray::number(REFRESH_MY_POKEMON);
  >     msg += ";" + QByteArray::number(pkm.num);
  >     msg += ";" + QByteArray::number(pkm.id);
  >     msg += ";" + pkm.name;
  >     msg += ";" + QByteArray::number(pkm.level);
  >     msg += ";" + QByteArray::number(pkm.exp);
  >     msg += ";" + QByteArray::number(pkm.hp);
  >     msg += ";" + QByteArray::number(pkm.power);
  >     msg += ";" + QByteArray::number(pkm.defence);
  >     msg += ";" + QByteArray::number(pkm.attack_interval);
  >     send_data(msg, sender_ip, sender_port);
  > }
  > ```
  >
  > 为用户更新精灵信息
  >
  > ```c++
  > void myserver::change_pkm(QList<QByteArray> list)
  > {
  >     my_pokemon temp;
  >     temp.num = list[0].toInt();
  >     temp.id = list[1].toInt();
  >     temp.name = list[2];
  >     temp.level = list[3].toInt();
  >     temp.exp = list[4].toInt();
  >     temp.hp = list[5].toInt();
  >     temp.power = list[6].toInt();
  >     temp.defence = list[7].toInt();
  >     temp.attack_interval = list[8].toInt();
  >     temp.user_id = list[9];
  >     mydatabase_->updatePokemon(temp);
  > }
  > ```
  >
  > 为用户删除精灵
  >
  > ```c++
  > void myserver::delete_pkm(QList<QByteArray> list)
  > {
  >     int num = list[0].toInt();
  >     mydatabase_->deletePokemon(num);
  > }
  > ```
  >
  > 发送用户自己的精灵信息
  >
  > ```c++
  > void myserver::send_my_pokemon(QVector<QVector<QString>> pokemon_list, QHostAddress sender_ip, quint16 sender_port)
  > {
  > 	//由于用户精灵数量一定大于等于0，此处不做判断
  >     for(int j=0;j<pokemon_list.size();j++)
  >     {
  >         QByteArray msg;
  >         msg = QString::number(REFRESH_MY_POKEMON).toUtf8();
  >         for(int i=0;i<pokemon_list.at(j).size();i++)
  >         {
  >             msg += ";" + pokemon_list.at(j).at(i);
  >         }
  >         send_data(msg, sender_ip, sender_port);
  >     }
  > }
  > ```
  >
  > 更新用户信息
  >
  > ```c++
  > void myserver::update_user_info(QList<QByteArray> list)
  > {
  >     myuser user;
  >     user.user_id = list[0];
  >     user.win_count = list[1].toInt();
  >     user.total_count = list[2].toInt();
  >     user.senior_pkm_medal = list[3].toInt();
  >     user.number_pkm_medal = list[4].toInt();
  >     user.wincount_medal = list[5].toInt();
  >     user.primary_medicine = list[6].toInt();
  >     user.junior_medicine = list[7].toInt();
  >     user.senior_medicine = list[8].toInt();
  >     user.status_medicine = list[9].toInt();
  >     user.money = list[10].toInt();
  >     mydatabase_->updateUser(user);
  > }
  > ```
  >
  > 初始化用户信息
  >
  > ```c++
  > void myserver::init_my_user(QByteArray user_id, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     QVector<QByteArray> user;
  >     QByteArray msg;
  >     msg = QByteArray::number(INIT_MY_USER);
  >     msg += ";" + user_id;
  >     mydatabase_->getUser(user_id, user);
  >     for(int i=2;i<user.size();i++)
  >     {
  >        msg += ";" + user.at(i);
  >     }
  >     send_data(msg, sender_ip, sender_port);
  > }
  > ```
  >
  > 获取服务器精灵
  >
  > ```c++
  > void myserver::init_server_pkm(QVector<QVector<QString>> pokemon_list, QHostAddress sender_ip, quint16 sender_port)
  > {
  >     for(int j=0;j<pokemon_list.size();j++)
  >     {
  >         QByteArray msg;
  >         msg = QByteArray::number(GET_SERVER_PKM);
  >         for(int i=0;i<pokemon_list.at(j).size();i++)
  >         {
  >             msg += ";" + pokemon_list.at(j).at(i);
  >         }
  >         send_data(msg, sender_ip, sender_port);
  >     }
  > }
  > ```
  >
  > **接收数据报**
  >
  > ```c++
  > void myserver::receive_data()
  > {
  >     while(myReceivingSocket->hasPendingDatagrams())
  >     {
  >         qDebug("data received");
  >         QHostAddress sender_ip;
  >         quint16 sender_port;
  >         QByteArray msg;
  >         msg.resize(myReceivingSocket->pendingDatagramSize());
  >         myReceivingSocket->readDatagram(msg.data(), msg.size(), &sender_ip, &sender_port);
  >         qDebug()<<msg;
  >         QList<QByteArray> list = msg.split(';');
  >         int manipulate = list[0].toInt();
  >         list.pop_front();
  >         QString user_id, user_password;
  > 
  >         switch (manipulate)
  >         {
  >         case GET_SERVER_IP:
  >             qDebug()<<"Get IP";
  >             send_ip(sender_ip, sender_port+1);
  >             break;
  > 
  >         case LOGIN:
  >             user_id = list[0];
  >             user_password = list[1];
  >             qDebug()<<"Login,"<<user_id<<","<<user_password;
  >             if(login(user_id, user_password, sender_ip, sender_port+1))
  >                 send_my_pokemon(mydatabase_->get_pokemonlist(user_id), sender_ip, sender_port+1);
  >             break;
  > 
  >         case REGISTER:
  >             user_id = list[0];
  >             user_password = list[1];
  >             qDebug()<<"Register,"<<user_id<<","<<user_password;
  >             regist(user_id, user_password, sender_ip, sender_port+1);
  >             break;
  > 
  >         case GET_USERS:
  >             qDebug()<<"Get users";
  >             send_userlist(mydatabase_->get_userlist(), sender_ip, sender_port+1);
  >             break;
  > 
  >         case GET_POKEMONLIST:
  >             qDebug()<<"Get Pokemon list";
  >             user_id = list[0];
  >             send_pokemonlist(mydatabase_->get_pokemonlist(user_id), sender_ip, sender_port+1);
  >             break;
  > 
  >         case EXIT:
  >             qDebug()<<"Exit";
  >             user_id = list[0];
  >             refresh_online_user(user_id, OFFLINE);
  >             break;
  > 
  >         case UPDATE_PKM:
  >             qDebug()<<"Update pokemon";
  >             switch(list[0].toInt())
  >             {
  >             case NEW_PKM:
  >                 list.pop_front();
  >                 new_pkm(list, sender_ip, sender_port+1);
  >                 break;
  > 
  >             case CHANGE_PKM:
  >                 list.pop_front();
  >                 change_pkm(list);
  >                 break;
  > 
  >             case DELETE_PKM:
  >                 list.pop_front();
  >                 delete_pkm(list);
  >                 break;
  >             }
  >             break;
  > 
  >         case UPDATE_USER_INFO:
  >             qDebug()<<"Update user info";
  >             update_user_info(list);
  >             break;
  > 
  >         case INIT_MY_USER:
  >             qDebug()<<"Init my user";
  >             init_my_user(list[0], sender_ip, sender_port+1);
  >             break;
  > 
  >         case GET_SERVER_PKM:
  >             qDebug()<<"Get server pkm";
  >             init_server_pkm(mydatabase_->get_pokemonlist("server"), sender_ip, sender_port+1);
  >             break;
  >         }
  >     }
  > }
  > ```

- mydatabase

  > 此处使用的是Qsql数据库，方便与Qt交互。有两个表，一个用户表，一个精灵表，这样方便存储变长信息（精灵数量），若用一个表存储则用户的精灵数有上限。为精灵添加一个主人属性，方便查找。
  >
  > 服务器精灵以用户server的精灵的形式存储在精灵表中

  > 构造函数，（创建）打开数据库
  >
  > ```c++
  > mydatabase::mydatabase()
  > {
  >     db = QSqlDatabase::addDatabase("QSQLITE");
  >     db.setDatabaseName("db");
  >     qDebug("database created");
  >     if(!db.open())
  >         qDebug()<<"database failed to open";
  >     createTable();
  > }
  > ```
  >
  > 创建用户表和精灵表
  >
  > ```c++
  > void mydatabase::createTable()
  > {
  >     QSqlQuery query;
  >     query.prepare(create_user_tbl);
  >     if(!query.exec())
  >        qDebug()<<"failed to create User table";
  >     else
  >         qDebug()<<"User table created";
  > 
  >     query.prepare(create_pkm_tbl);
  >     if(!query.exec())
  >         qDebug()<<"failed to create Pokemon table";
  >     else
  >         qDebug()<<"Pokemon table created";
  > }
  > ```
  >
  > 增添用户，若成功返回true，否则返回false
  >
  > ```c++
  > bool mydatabase::insertUser(myuser user)
  > {
  >     QSqlQuery query;
  >     query.prepare(insert_user_tbl);
  >     query.bindValue(0,user.user_id);
  >     query.bindValue(1,user.user_password);
  >     query.bindValue(2,user.win_count);
  >     query.bindValue(3,user.total_count);
  >     query.bindValue(4,user.senior_pkm_medal);
  >     query.bindValue(5,user.number_pkm_medal);
  >     query.bindValue(6,user.wincount_medal);
  >     query.bindValue(7,user.primary_medicine);
  >     query.bindValue(8,user.junior_medicine);
  >     query.bindValue(9,user.senior_medicine);
  >     query.bindValue(10,user.status_medicine);
  >     query.bindValue(11,user.money);
  >     user.print();
  >     if(!query.exec())
  >     {
  >         qDebug("failed to insert user");
  >         return false;
  >     }
  >     else
  >     {
  >         qDebug()<<"inserted user successfully";
  >         return true;
  >     }
  > }
  > ```
  >
  > 更新用户信息，若成功返回true，否则返回false
  >
  > ```c++
  > void mydatabase::updateUser(myuser user)
  > {
  >     qDebug()<<"updateuser";
  >     qDebug()<<user.primary_medicine;
  >     QSqlQuery query;
  >     query.prepare("update user set win_count = :win_count ,\
  >                                    total_count = :total_count ,\
  >                                    senior_pkm_medal = :senior_pkm_medal ,\
  >                                    number_pkm_medal = :number_pkm_medal ,\
  >                                    wincount_medal = :wincount_medal ,\
  >                                    primary_medicine = :primary_medicine ,\
  >                                    junior_medicine = :junior_medicine ,\
  >                                    senior_medicine = :senior_medicine ,\
  >                                    status_medicine = :status_medicine ,\
  >                                    money = :money \
  >                                    where user_id = :user_id");
  >     query.bindValue(":win_count",user.win_count);
  >     query.bindValue(":total_count",user.total_count);
  >     query.bindValue(":senior_pkm_medal",user.senior_pkm_medal);
  >     query.bindValue(":number_pkm_medal",user.number_pkm_medal);
  >     query.bindValue(":wincount_medal",user.wincount_medal);
  >     query.bindValue(":primary_medicine",user.primary_medicine);
  >     query.bindValue(":junior_medicine",user.junior_medicine);
  >     query.bindValue(":senior_medicine",user.senior_medicine);
  >     query.bindValue(":status_medicine",user.status_medicine);
  >     query.bindValue(":money",user.money);
  >     query.bindValue(":user_id",user.user_id);
  >     if(query.exec())
  >         qDebug("update user successfully");
  >     else
  >         qDebug("update user failed");
  > }
  > ```
  >
  > 获取某用户信息，成功返回true，否则返回false
  >
  > ```c++
  > bool mydatabase::getUser(QString user_id, QVector<QByteArray> &user)
  > {
  >     QSqlQuery query;
  >     query.prepare("select * from user where user_id=:user_id");
  >     query.bindValue(":user_id", user_id);
  >     query.exec();
  >     user.append(user_id.toUtf8());
  >     if(query.next())
  >     {
  >         for(int i=1;i<12;i++)
  >             user.append(query.record().value(i).toByteArray());
  >         return true;
  >     }
  >     else
  >         return false;
  > }
  > ```
  >
  > 打印用户表（用于测试）
  >
  > ```c++
  > void mydatabase::printUserTable()
  > {
  >     QSqlQuery query;
  >     query.prepare(select_all_user_tbl);
  >     if(query.exec())
  >     {
  >         while(query.next())
  >         {
  >             for(int i=0;i<2;i++)
  >                 qDebug()<<query.record().fieldName(i)<<query.record().value(i);
  >         }
  >     }
  >     else
  >         qDebug("error");
  > }
  > ```
  >
  > 增添精灵，若成功返回true，否则返回false
  >
  > ```c++
  > bool mydatabase::insertPokemon(my_pokemon pkm)
  > {
  >     QSqlQuery query;
  >     query.prepare(insert_pkm_tbl);
  >     query.bindValue(0,pkm.num);
  >     query.bindValue(1,pkm.id);
  >     query.bindValue(2,pkm.name);
  >     query.bindValue(3,pkm.level);
  >     query.bindValue(4,pkm.exp);
  >     query.bindValue(5,pkm.hp);
  >     query.bindValue(6,pkm.power);
  >     query.bindValue(7,pkm.defence);
  >     query.bindValue(8,pkm.attack_interval);
  >     query.bindValue(9,pkm.user_id);
  >     if(!query.exec())
  >     {
  >         qDebug("failed to insert pokemon");
  >         return false;
  >     }
  >     else
  >     {
  >         qDebug()<<"inserted pokemon successfully";
  >         return true;
  >     }
  > }
  > ```
  >
  > 删除精灵
  >
  > ```c++
  > void mydatabase::updatePokemon(my_pokemon pkm)
  > {
  >     QSqlQuery query;
  >     query.prepare("update pkm set name = :name ,\
  >                                   id = :id ,\
  >                                   level = :level ,\
  >                                   exp = :exp ,\
  >                                   hp = :hp ,\
  >                                   power = :power ,\
  >                                   defence = :defence ,\
  >                                   attack_interval = :attack_interval \
  >                                   where num = :num");
  > 
  >     query.bindValue(":name", pkm.name);
  >     query.bindValue(":id",pkm.id);
  >     query.bindValue(":level", pkm.level);
  >     query.bindValue(":exp", pkm.exp);
  >     query.bindValue(":hp", pkm.hp);
  >     query.bindValue(":power", pkm.power);
  >     query.bindValue(":defence", pkm.defence);
  >     query.bindValue(":attack_interval", pkm.attack_interval);
  >     query.bindValue(":num", pkm.num);
  >     query.exec();
  > }
  > ```
  >
  > 获取最大精灵num（以便给新的精灵赋num）
  >
  > ```c++
  > int mydatabase::get_pkm_num()
  > {
  >     QSqlQuery query;
  >     query.prepare("select num from pkm");
  >     query.exec();
  >     int max = 0;
  >     while(query.next())
  >     {
  >         if(max < query.record().value(0).toInt())
  >             max = query.record().value(0).toInt();
  >     }
  >     return max;
  > }
  > ```
  >
  > 输出精灵表（测试用）
  >
  > ```c++
  > void mydatabase::printPkmTable()
  > {
  >     QSqlQuery query;
  >     query.prepare("select * from pkm");
  >     if(query.exec())
  >         while(query.next())
  >         {
  >             for(int i=0;i<10;i++)
  >                 qDebug()<<query.record().fieldName(i)<<query.record().value(i);
  >             qDebug("\n");
  >         }
  >     else
  >         qDebug("error");
  > }
  > ```
  >
  > 获取用户列表
  >
  > ```c++
  > QVector<QVector<QString>> mydatabase::get_userlist()
  > {
  >     QSqlQuery query;
  >     QVector<QVector<QString>> user_list;
  >     query.prepare("select * from user");
  >     if(query.exec())
  >     {
  >         while(query.next())
  >         {
  >             QVector<QString> temp;
  >             temp.append(query.record().value(0).toString());//id
  >             temp.append(query.record().value(2).toString());//wincount
  >             temp.append(query.record().value(3).toString());//total
  >             temp.append(query.record().value(4).toString());//senior
  >             temp.append(query.record().value(5).toString());//number
  >             temp.append(query.record().value(6).toString());//win
  >             user_list.append(temp);
  >         }
  >     }
  >     return user_list;
  > }
  > ```
  >
  > 获取某用户的精灵列表
  >
  > ```c++
  > QVector<QVector<QString>> mydatabase::get_pokemonlist(QString user_id)
  > {
  >     QSqlQuery query;
  >     QVector<QVector<QString>> pokemon_list;
  >     query.prepare("select * from pkm where user_id =:user_id");
  >     query.bindValue(":user_id",user_id);
  >     query.exec();
  >     while(query.next())
  >     {
  >         QVector<QString> pokemon;
  >         for(int i=0;i<9;i++)
  >         {
  >             pokemon.append(query.record().value(i).toString());
  >         }
  >         pokemon_list.append(pokemon);
  >     }
  >     qDebug()<<pokemon_list;
  >     return pokemon_list;
  > }
  > ```

### 题目三

- battle_field

  > - battle_field是战斗类
  >
  > - 当比赛开始后，p1和p2会开始战斗。攻击次序按照攻击间隔决定，每次行动后都要累加一次攻击间隔，每回合开始时比较累加值，小的一方此回合行动。
  > - 此类只负责战斗，战斗结束后将结果和比赛形式返回给道馆类，进行结算

  > 战斗主体
  >
  > ```c++
  > void battle_field::battle()
  > {
  >     qDebug("enter battle");
  >     int lose_1 = 0, lose_2 = 0;
  >     //debuff结算
  >     if (p1->deal_with_debuff())
  >         lose_1 = 1;
  >     if (p2->deal_with_debuff())
  >         lose_2 = 1;
  > 
  >     if (lose_1 && lose_2)
  >     {
  >         end(0);//平局
  >         return;
  >     }
  >     else if(lose_1)
  >     {
  >         end(1);//p1输
  >         return;
  >     }
  >     else if(lose_2)
  >     {
  >         end(2);//p2输
  >         return;
  >     }
  > 
  >     if(p1_interval<=p2_interval)
  >     {
  >         //玩家回合
  >         emit insert_log("\n您的回合\n");
  >         qDebug("p1 turn");
  >         p1_interval += p1->get_speed();
  >         if (p1->get_status() == ELECTRICITY)//若麻痹，则跳过此回合
  >         {
  >             battle();
  >             return;
  >         }
  > 
  >         if(is_auto)//自动战斗
  >         {
  >             p1_move();
  >         }
  >         else
  >         {
  >             this->ui->attack_btn->setEnabled(true);
  >             ui->attack_btn->setAttribute(Qt::WA_TransparentForMouseEvents, false);
  >             if(p1->get_remaining_pp())//若pp有剩余，可以使用技能
  >             {
  >                 this->ui->skill_btn->setEnabled(true);
  >                 ui->skill_btn->setAttribute(Qt::WA_TransparentForMouseEvents, false);
  >             }
  >             this->ui->item_btn->setEnabled(true);
  >             ui->item_btn->setAttribute(Qt::WA_TransparentForMouseEvents, false);
  >         }
  >     }
  >     else
  >     {
  >         //对方回合
  >         emit insert_log("\n对方的回合\n");
  >         qDebug("p2 turn");
  >         p2_interval += p2->get_speed();
  >         if (p2->get_status() == ELECTRICITY)//若麻痹，则跳过此回合
  >         {
  >             battle();
  >             return;
  >         }
  >         p2_move();
  >     }
  > }
  > ```
  >
  > 用户的自动战斗
  >
  > ```c++
  > void battle_field::p1_move()
  > {
  >     int lose = 0;
  >     int manipulate = random_num_generator(0.7);//自动获取操作，0.3概率普通攻击,0.7概率使用技能
  >     if (!p1->get_remaining_pp())//pp不足只能普通攻击
  >         manipulate = 0;
  >     bullet *bul;
  > 
  >     switch (manipulate)
  >     {
  >     case 0://普通攻击
  >         bul = p1->attack();
  >         lose = p2->hit(bul);
  >         break;
  > 
  >     case 1://使用技能
  >         bul = p1->skill();
  >         lose = p2->hit(bul);
  >         break;
  >     }
  >     if(lose)
  >     {
  >         end(2);
  >         return;
  >     }
  >     //更新血量
  >     this->ui->p1_hp_bar->setValue(p1->get_hp());
  >     this->ui->p1_hp->setText(QString::number(p1->get_hp())+"/"+QString::number(p1->get_total_hp()));
  >     this->ui->p2_hp_bar->setValue(p2->get_hp());
  >     this->ui->p2_hp->setText(QString::number(p2->get_hp())+"/"+QString::number(p2->get_total_hp()));
  >     qDebug("更新血量");
  >     Sleep(1000);
  >     battle();//继续战斗
  > }
  > ```
  >
  > 电脑自动战斗
  >
  > ```c++
  > void battle_field::p2_move()
  > {
  >     int lose = 0;
  >     int manipulate = random_num_generator(0.7);//自动获取操作，0.3概率普通攻击,0.7概率使用技能
  >     if (!p2->get_remaining_pp())
  >         manipulate = 0;
  >     bullet *bul;
  >     switch (manipulate)
  >     {
  >     case 0://普通攻击
  >         bul = p2->attack();
  >         lose = p1->hit(bul);
  >         break;
  > 
  >     case 1://技能
  >         bul = p2->skill();
  >         lose = p1->hit(bul);
  >         break;
  >     }
  >     if(lose)
  >     {
  >         end(1);
  >         return;
  >     }
  >     this->ui->p1_hp_bar->setValue(p1->get_hp());
  >     this->ui->p1_hp->setText(QString::number(p1->get_hp())+"/"+QString::number(p1->get_total_hp()));
  >     this->ui->p2_hp_bar->setValue(p2->get_hp());
  >     this->ui->p2_hp->setText(QString::number(p2->get_hp())+"/"+QString::number(p2->get_total_hp()));
  >     Sleep(1000);
  >     battle();//继续战斗
  > }
  > ```
  >
  > 当用户自主战斗时，按钮触发signal，调用相应函数
  >
  > ```c++
  > //p1攻击
  > void battle_field::p1_attack()
  > {
  >     p1_move(0, 0);
  > }
  > 
  > //p1技能
  > void battle_field::p1_skill()
  > {
  >     p1_move(1, 0);
  > }
  > 
  > //p1道具
  > void battle_field::p1_item()
  > {
  >     QStringList list;
  >     if(user->primary_medicine)
  >         list<<tr("伤药");
  >     if(user->junior_medicine)
  >         list<<tr("好伤药");
  >     if(user->senior_medicine)
  >         list<<tr("超好伤药");
  >     if(user->status_medicine)
  >         list<<tr("异常状态恢复药");
  >     bool ok;
  >     QString item = QInputDialog::getItem(this,tr("使用物品"),tr("请选择你要使用的物品"),list, 0, false, &ok);
  >     if(ok)
  >     {
  >         if(item=="伤药")
  >             p1_move(2, 0);
  >         else if(item=="好伤药")
  >             p1_move(2, 1);
  >         else if(item=="超好伤药")
  >             p1_move(2, 2);
  >         else if(item=="异常状态恢复药")
  >             p1_move(2, 3);
  >     }
  > }
  > ```

- battle_ground

  > - 结算结束后会将精灵信息和用户信息向服务器更新。
  > - 获得战斗结果后结算过程结构清晰，此处不再赘述。


## 四、界面设计

- 登录界面

  > 登录主界面
  >
  > ![1546343232766](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546343232766.png)

  1. 点击登录后

     > 点击右侧返回按钮可返回登录主界面
     >
     > ![1546343290785](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546343290785.png)

  2. 点击注册后

     > 点击右侧返回按钮可返回登录主界面
     >
     > ![1546343309323](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546343309323.png)

- 主界面

  > 点击背包打开背包界面
  >
  > 点击精灵打开精灵界面
  >
  > 点击用户列表打开用户列表界面
  >
  > 点击神奇宝贝中心打开神奇宝贝中心界面
  >
  > 点击道馆打开道馆界面
  >
  > ![主界面](C:\Users\dell1\Desktop\主界面.jpg)

- 背包界面

  > ![1546344176295](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344176295.png)

- 精灵界面

  > 可查看自己拥有的精灵的详细信息
  >
  > 可以给精灵更改名字，更改完毕后用回车确认。但是对于名字的更改需要重新登录才能生效
  >
  > ![1546344224163](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344224163.png)

- 用户列表

  > 可以拖动滚动条以查看其它条目
  >
  > 点击不同条目可按不同条件给用户排序，如是否在线、胜场数、胜率
  >
  > **点击某一行可以显示该用户的精灵信息，注意在此处查看精灵信息没有通过工具栏查看精灵信息详细，没有当前属性值只有满状态属性值，详见下侧图例**
  >
  > 再次点击用户列表可关闭该界面
  >
  > ![1546344331603](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344331603.png)![1546344349002](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344349002.png)
  >
  > ![1546344771271](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344771271.png)

- 神奇宝贝中心界面

  >  在左侧可购买相应道具，右侧可恢复精灵体力
  >
  > ![1546344551707](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344551707.png)

- 道馆界面

  > 左侧可以选择自己的出战精灵，右侧可以选择电脑的出战精灵
  >
  > 中间的框选处可勾选是否开启自动战斗
  >
  > 点击升级赛后开始升级赛
  >
  > 点击决斗赛后开始决斗赛
  >
  > 点击返回回到主界面
  >
  > ![1546344600297](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546344600297.png)
  >
  >
  >
  > 在非自动战斗状态下，用户可在自己的回合选择攻击、技能、使用道具3种操作
  >
  > ![1546345200554](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546345200554.png)
  >
  > 道具使用窗口
  >
  > ![1546345367918](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546345367918.png)
  >
  > 战斗结束
  >
  > ![1546345440987](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546345440987.png)
  >
  > ![1546345475329](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546345475329.png)

- 退出

  > ![1546345524257](C:\Users\dell1\AppData\Roaming\Typora\typora-user-images\1546345524257.png)
